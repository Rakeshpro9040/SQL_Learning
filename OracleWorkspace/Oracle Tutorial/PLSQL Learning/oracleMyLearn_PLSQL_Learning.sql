*****************************************
Instructions:
*****************************************

This File Contains content from below sites:
https://mylearn.oracle.com/course/oracle-database-19c-plsql-workshop/38560/78807

Login to ADB_USER@ADB.
You can find HR tables in HR@ADB. For more info check ADB section.
You can find oracletutorial databse in OT@ADB.


*****************************************
Misc
*****************************************

-- Autonomous Transactions
CREATE TABLE at_test (
  id           NUMBER       NOT NULL,
  description  VARCHAR2(50) NOT NULL
);
/

INSERT INTO at_test (id, description) VALUES (1, 'Description for 1');
INSERT INTO at_test (id, description) VALUES (2, 'Description for 2');

SELECT * FROM at_test;

CREATE TABLE error_logs (
  id   NUMBER GENERATED BY DEFAULT AS IDENTITY,
  log_timestamp  TIMESTAMP      NOT NULL,
  error_message  VARCHAR2(4000),
  CONSTRAINT error_logs_pk PRIMARY KEY (id)
);

CREATE OR REPLACE PROCEDURE log_errors (p_error_message  IN  VARCHAR2) AS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO error_logs (log_timestamp, error_message)
  VALUES (SYSTIMESTAMP, p_error_message);
  --COMMIT;
END;
/

BEGIN
  INSERT INTO at_test (id, description)
  VALUES (998, 'Description for 998');

  -- Force invalid insert.
  INSERT INTO at_test (id, description)
  VALUES (999, NULL);
EXCEPTION
  WHEN OTHERS THEN
    log_errors (p_error_message => SQLERRM);
    ROLLBACK;
END;
/

-- 1st Run:
-- Error due to AUTONOMOUS_TRANSACTION block was not commited/rolled back explicitly
-- 2nd Run: Success

CREATE OR REPLACE PROCEDURE log_errors (p_error_message  IN  VARCHAR2) AS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO error_logs (log_timestamp, error_message)
  VALUES (SYSTIMESTAMP, p_error_message);
  COMMIT;
END;
/

select * from at_test; -- rolled back
select * from error_logs; -- commit not impacted by the exception block roll back



*****************************************
Practice Exam
*****************************************

-- Qn
SET SERVEROUTPUT ON;
DECLARE
c_id employees.employee_id%type; c_name employees.first_name%type;
CURSOR c_emp IS SELECT employee_id, first_name FROM employees;
BEGIN
    --OPEN c_emp;
    LOOP
     FETCH c_emp into c_id, c_name;
           EXIT WHEN c_emp%notfound;
      dbms_output.put_line(c_id || ' ' || c_name);
     END LOOP;
    CLOSE c_emp;
END;
/

-- Qn
declare
 i integer := 1;
 j integer;
begin
loop
    dbms_output.put_line(i);
    exit when i > 9;
    j := i;
    loop
        exit when j = 0;
        dbms_output.put_line('*');        
        j := j - 1;
    end loop;
    i := i + 1;
end loop;
end;
/

-- Qn
declare
    --2_mile number; -- Can't start with a number
    --$mile number; -- Can't start with $, system variable
    --mile,nbr number; -- Can't have , init
    mile#_nbr number; -- Can have # or _
    mile_2 number; -- Can have number init
    this_is_a_user_defined_variable number; - till 12c Max allowed was 30 Char
begin
    null;
end;
/

-- Qn
DECLARE
v_hiredate DATE := '12-June-2020';
v_salary REAL := 25000;
v_comm CONSTANT NUMBER; -- initialization for a CONSTANT is mandatory
--v_comm CONSTANT NUMBER := 5;
BEGIN
DBMS_OUTPUT.PUT_LINE ('Hire date '  || v_hiredate);
DBMS_OUTPUT.PUT_LINE ('Salary '  || v_salary);
DBMS_OUTPUT.PUT_LINE (v_comm);
END;
/

-- Qn
drop package hr.demopkg; -- PKG specification dropped successfully
drop package body compile_pkg; -- PKG body dropped successfully

-- Qn
SET SERVEROUTPUT ON;
VARIABLE v_bind1 VARCHAR2(20);

BEGIN
:v_bind1 := 'Rakesh';
END;
/
Print v_bind1;



*****************************************
PL/SQL Variables
*****************************************

-- Implicit conversion
select 1+'2' from dual; --3
select to_date('02-FEB-2021') from dual; -- 02-FEB-21

-- Explicit conversion
select to_date('February, 02 2021', 'Month, DD YYYY') from dual; -- 02-FEB-21

-- Alternative quote operator
select e.last_name || q'[ isn't a ]' || e.job_id
from employees e;

-- Bind Variables
VARIABLE x number
declare
    y number;
begin
    y := 100;
    :x := 101;
    --dbms_output.put_line(x); -- Error
    dbms_output.put_line(y);
end;
/
PRINT
select * from employees where employee_id = :x;

-- AUTOPRINT will auto print Bind variables
VARIABLE x number
SET AUTOPRINT ON
declare
    y number;
begin
    y := 100;
    :x := 101;
    --dbms_output.put_line(x); -- Error
    dbms_output.put_line(y);
end;
/
select * from employees where employee_id = :x;

*****************************************
PL/SQL Blocks
*****************************************

-- Simple PLSQL Blocks
SET SERVEROUTPUT ON;
DECLARE
    v_lname VARCHAR2(20);
BEGIN
    SELECT
        e.last_name
    INTO v_lname
    FROM
        hr.employees e
    where e.employee_id = 100;

    dbms_output.put_line(v_lname);
END;

-- Using Sequences in PL/SQL Block
create sequence my_seq
increment by 1
start with 1
nomaxvalue;

declare
    v_new_id number;
begin
    v_new_id := my_seq.NEXTVAL;
    dbms_output.put_line(v_new_id);
    dbms_output.put_line(my_seq.CURRVAL);
    dbms_output.put_line(my_seq.NEXTVAL);
end;
/

drop sequence my_seq;

-- Nested Block
begin <<outer>>
declare
    v_sal number(7,2) := 6000;
    v_comm number(7,2) := v_sal*0.20;
    v_message varchar2(255) := ' eligible for commission';
begin
    dbms_output.put_line('v_comm-1: ' || v_comm);
    declare
        v_sal number(7,2) := 50000;
        v_comm number(7,2) := 0;
        v_total_comp number(7,2) := v_sal + v_comm;
        --v_message varchar2(255) := 'lalala';
    begin
        v_message := 'CLERK not' || v_message; 
        -- This will override the outer block v_message, due to not declared in inner block
        v_sal := v_sal+100;
        -- This will not override the outer block v_sal, due to declared in inner block
        v_comm := v_sal*0.30;
        dbms_output.put_line('v_message-1: ' || v_message);
        dbms_output.put_line('v_sal-1: ' || v_sal);
        dbms_output.put_line('v_comm-2: ' || v_comm);
        dbms_output.put_line('v_comm-3: ' || outer.v_comm);
        outer.v_comm := v_sal*0.30;
        -- This will override the outer block v_sal, due to access through outer lable
    end;
    
    v_sal := v_sal+100;
    v_message := 'SALESMAN' || v_message;
    dbms_output.put_line('v_message-2: ' || v_message);
    dbms_output.put_line('v_sal-2: ' || v_sal);
    dbms_output.put_line('v_comm-4: ' || v_comm);
end;
end outer;

*****************************************
Using SQL Statements within a PL/SQL Block
*****************************************

-- SQL Cursor (Implicit)
SET SERVEROUTPUT ON;
declare
    v_empid number := 99;
begin
    delete from employees where employee_id = v_empid;
    dbms_output.put_line('Total ' || SQL%ROWCOUNT || ' rows deleted.');
end;

*****************************************
Writing Control Structures
*****************************************
-- CASE
-- Standard
-- Here we can ony add one search condition and equi comparisions
select e.last_name, 
    e.job_id, 
    e.salary,
    case job_id 
        when 'AD_PRES' then salary*2
        when 'AD_VP' then salary*1.5
        else salary*.5
    end as raise_or_not
from employees e;

-- Searched
-- Here we can add additional conditions and non-equi comparisions
select e.last_name, 
    e.job_id, 
    e.salary,
    case  
        when job_id= 'AD_PRES' then salary*2
        when job_id='AD_VP' and last_name= 'Kochhar' then salary*1.5
        else salary*.5
    end as raise_or_not
from employees e;

-- Handling NULLs
-- TRUE OR NULL = TRUE
select 
    case 
        when ((1 = 1) OR (1 > NULL)) then 1
        else 0
    end as test_col
from dual; -- 1

-- FALSE AND NULL = FALSE
select 
    case 
        when NOT((1 = 2) AND (1 > NULL)) then 1
        else 0
    end as test_col
from dual; -- 1

-- LOOP
-- Executes atleast once
SET SERVEROUTPUT ON;
DECLARE
    v_val NUMBER := 0;
BEGIN
    LOOP       
        EXIT WHEN v_val > 10;
        dbms_output.put_line(v_val);
        v_val := v_val + 1;
    END LOOP;
END;
-- 0..10

-- WHILE
-- Always checks the condition before the LOOP starts
DECLARE
    v_val NUMBER := 0;
BEGIN
    WHILE (v_val > 10) LOOP       
        dbms_output.put_line(v_val);
        v_val := v_val + 1;
    END LOOP;
END;
-- 0..10

-- FOR
-- Executes a defined number of times
DECLARE
BEGIN
    FOR i in 1..10 LOOP
    -- 1..10 is called bounds (lower-upper)
    -- i is called as implied counter
    -- We can't increment or re-define i
        dbms_output.put_line(i);
    END LOOP;
END;
-- 1..10

DECLARE
BEGIN
    FOR i in REVERSE 1..10 LOOP
        dbms_output.put_line(i);
    END LOOP;
END;
-- 10..1

-- CONTINUE
SET SERVEROUTPUT ON;
declare
    v_total simple_integer := 0;
begin
    for i in 1..10 loop
        v_total := v_total+i;
        dbms_output.put_line('Total is: '||v_total);
        continue when i>5;
        v_total := v_total+i;
        dbms_output.put_line('Out of loop Total is: '||v_total);
    end loop;
end;

*****************************************
Composite Datatype
*****************************************
-- TYPE
declare
    TYPE emptype is record (v_fname varchar2(25), v_lname varchar2(25));
    emprecord emptype;
begin
    select e.first_name, e.last_name
    into emprecord
    from employees e
    where e.employee_id = 100;
    
    dbms_output.put_line(emprecord.v_fname||' '|| emprecord.v_lname);
end;
--Steven King

-- ROWTYPE
declare
    emprecord employees%rowtype;
begin
    select e.*
    into emprecord
    from employees e
    where e.employee_id = 100;
    
    dbms_output.put_line(emprecord.first_name||' '|| emprecord.last_name);
end;
--Steven King

-- row-level INSERT
create table t as select * from hr.employees where 1=2;

declare
    emprecord employees%rowtype;
begin
    select e.*
    into emprecord
    from employees e
    where e.employee_id = 100;
    
    insert into t values emprecord;
end;

SELECT * FROM t;
-- Steven row inserted

drop table t;

-- row-level UPDATE
declare
    emprecord employees%rowtype;
begin
    select e.*
    into emprecord
    from employees e
    where e.employee_id = 110;
    
    update t set row = emprecord where employee_id = 100;
end;

select * from t;
-- John row copied

-- Associative Arrays
SET SERVEROUTPUT ON;
declare
    type emptype is table of employees%ROWTYPE index by pls_integer;
    emptable emptype;
begin
    for i in 100..110 loop
        select *
        into emptable(i)
        from employees
        where employee_id = i;
    end loop;
    
    dbms_output.put_line('Total emptable count: ' || emptable.COUNT);
    emptable.delete(105);
    dbms_output.put_line('Total emptable count after deleting emp id 105: ' || emptable.COUNT);
    
    for j in emptable.first.. emptable.last loop
        if emptable.exists(j) then
            dbms_output.put_line('-----------');
            dbms_output.put_line('Prior Index: '||emptable.prior(j));
            dbms_output.put_line('Hiredate: '||emptable(j).hire_date);
            dbms_output.put_line('Next Index: '||emptable.next(j));
        else
            null;
        end if;
    end loop;   
end;

*****************************************
Explicit Cursors
*****************************************
SET SERVEROUTPUT ON;
declare
    cursor empcursor is
     select *
     from employees;
    
    emprecord empcursor%ROWTYPE;
begin
    open empcursor;
    loop
        fetch empcursor into emprecord;
        exit when empcursor%notfound;
        dbms_output.put_line('Last name: '||emprecord.last_name);
    end loop;
    close empcursor;
end;

-- Parameterized Cursor
declare
    cursor empcursor(pdept number) is
     select *
     from employees e
     where e.department_id = pdept;
    
    emprecord employees%ROWTYPE;
begin
    open empcursor(10);
    loop
        fetch empcursor into emprecord;
        exit when empcursor%notfound;
        dbms_output.put_line('Last name: '||emprecord.last_name);
    end loop;
    
    if empcursor%isopen then
        close empcursor;
        dbms_output.put_line('empcursor is now closed!');
    else
        null;
    end if;

    open empcursor(20);
    loop
        fetch empcursor into emprecord;
        exit when empcursor%notfound;
        dbms_output.put_line('Last name: '||emprecord.last_name);
    end loop;
    close empcursor;
end;

-- FOR Loop Syntax
declare
    cursor empcursor(pdept number) is
     select *
     from employees e
     where e.department_id = pdept;
    
begin
    for emprecord in empcursor(90) loop
        dbms_output.put_line('Last name: '||emprecord.last_name);
    end loop;
end;

declare
    cursor empcursor is
     select *
     from employees e;
    
begin
    for emprecord in empcursor loop
        exit when emprecord.employee_id = 105;
        dbms_output.put_line('Last name: '||emprecord.employee_id);
    end loop;
end;

-- FOR UPDATE & WHERE CURRENT OF
declare
    cursor empcursor is
     select *
     from employees e
     for update
     --wait 10 -- wait 10 sec for the lock by other user to release
     nowait; -- do not wait and throw resource busy exception if rows are locked by other user
    
begin
    for emprecord in empcursor loop
        update employees e
        set e.salary = e.salary+1
        where current of empcursor;
    end loop;
end;

rollback;
-- To test this one run this block and open an "Unshared worksheet"
-- and run a new update and see if its able to acquire lock

-- FOR UPDATE & WHERE CURRENT OF (Column ref)
declare
    cursor empcursor is
     select *
     from employees e
     for update of salary
     nowait;
    
begin
    for emprecord in empcursor loop
        update employees e
        set e.salary = e.salary+1
        where current of empcursor;
    end loop;
end;

*****************************************
Exceptions
*****************************************
-- Internally Predefined
SET SERVEROUTPUT ON;
declare
    e_oops exception;
    pragma exception_init(e_oops, -01400);
begin
    insert into departments
    values(900, null, null, null);
    
exception
    when e_oops then
        dbms_output.put_line('sql code: '||SQLCODE);
        dbms_output.put_line('sql error message: '||SQLERRM);
        dbms_output.put_line('No nulls for deptname');
end;
/*
sql code: -1400
sql error message: ORA-01400: cannot insert NULL into ("HR"."DEPARTMENTS"."DEPARTMENT_NAME")
No nulls for deptname
*/

-- User defined
-- Interrupt program abruptly (exit code=1)
begin
    delete from employees where employee_id = 99;
    if sql%notfound then
        raise_application_error(-20000, 'Nobody with that id');
        -- Error code allowed between -20000 to -20999
    end if;
end;

declare
    e_no_id exception;
begin
    delete from employees where employee_id = 99;
    if sql%notfound then
        raise e_no_id;
    end if;
exception
    when e_no_id then
        raise_application_error(-20000, 'Nobody with that id');
end;

/*
Error report -
ORA-20000: Nobody with that id
ORA-06512: at line 4
*/

-- Exit program gracefully (exit code=0)
declare
    e_no_id exception;
begin
    delete from employees where employee_id = 99;
    if sql%notfound then
        raise e_no_id;
    end if;
exception
    when e_no_id then
        dbms_output.put_line('Nobody with that id');
end;

*****************************************
Procedures
*****************************************
-- Create Procedure
create or replace procedure insert_t_proc
    (pid number,
    pname varchar) 
as
begin
    insert into t
    values(pid, pname);
exception
    when others then
        dbms_output.put_line('Error!');
end insert_t_proc;
/
--show errors -- Show compilation errors in SQL*PLUS output

-- Invoke Procedure
begin
    insert_t_proc(1, 'King');
end;
/
select * from t;

-- Parameterized Procedure
create or replace procedure format_phone
    (p_phone_no IN OUT VARCHAR2)
is
begin
    p_phone_no := '(' || substr(p_phone_no,1,3) ||
                  ')' || substr(p_phone_no,4,3) ||
                  '-' || substr(p_phone_no,7);
end format_phone;
/

variable b_phone_no varchar2(15)
execute :b_phone_no := '8006330575' 
-- Initilzing IN OUT variable, as we are going to use this while calling the proc
print b_phone_no
execute format_phone (:b_phone_no)
print b_phone_no

-- Quiz
create or replace procedure add_nbr
    (a in number default 10,
    b in number default 20,
    c out number,
    d in number default 30)
is
    e number;
begin
    e := a*2;
    c := e+b+d;
end add_nbr;
/

variable c number
--execute add_nbr(10, 20, :c) --70
--execute add_nbr(10, 20, c => :c); --70
--execute add_nbr(:c,20) -- Error: Wrong position
--execute add_nbr(i => 20, j => 40, k => :c) -- Error: Wrong Param name
--execute add_nbr(a => 20, b => 40, c => :c) --110
--execute add_nbr(b => 20, a => 40, c => :c) --130
print c

*****************************************
Functions
*****************************************
-- Create Function
create or replace function get_emp
    (pid number)
return varchar2 
as
    v_lname varchar2(25);
begin
    select e.last_name
    into v_lname
    from employees e
    where e.employee_id = pid;
    
    --return v_lname;
end get_emp;
/
show error
/

-- Invoke Function
-- Way-1 (using select/dml statement)
select employee_id, get_emp(employee_id) from employees;

-- Way-2 (using pl/sql block)
declare
    v_lname varchar2(25); 
begin
    v_lname := get_emp(100);
    dbms_output.put_line(v_lname);
end;

-- Way-3 (using execute statement)
variable v_lname varchar2(25)
execute :v_lname := get_emp(100)
print v_lname


*****************************************
Debugging Subprograms
*****************************************
$ipconfig
select * from dba_host_acls;
select * from dba_network_acls;

-- To check user privileges
select * from user_sys_privs;

-- Run the below commands from ADMIN@ADB
grant debug any procedure to HR;
grant debug connect session to HR;
grant execute on dbms_debug_jdwp to HR;

BEGIN
    dbms_network_acl_admin.append_host_ace
       (HOST=>'adb.ap-hyderabad-1.oraclecloud.com',
        lower_port => null,
        upper_port => null,
        ace=> SYS.xs$ace_type(privilege_list=>SYS.xs$name_list('JDWP'),
                   principal_name=>'HR',
                   principal_type=>SYS.xs_acl.ptype_db) 
       );
END;
/
COMMIT;

-- Remote Debugging
EXEC DBMS_DEBUG_JDWP.CONNECT_TCP('192.168.1.36', '65471');

-- Test
ALTER PROCEDURE add_nbr compile debug;

SELECT
    plsql_debug,
    plsql_warnings,
    plscope_settings
FROM
    dba_plsql_object_settings
WHERE
        owner = 'HR'
    AND name = 'ADD_NBR';
    
*****************************************
Packages
*****************************************
-- Refer to code_ex_15 and sol_06

-- Create a Package
-- Specification
CREATE OR REPLACE PACKAGE demopkg IS
    PROCEDURE update_sal (
        pid     NUMBER,
        psalary NUMBER
    );

    PROCEDURE get_emp (
        pid   NUMBER,
        pname OUT VARCHAR
    );

END demopkg;
/
-- Body
-- Let the Wizard create the body depending on the Spec

-- Invoke
begin
    demopkg.update_sal(100,1);
end;
select * from employees where employee_id=100;

*****************************************
UTL_FILE
*****************************************
-- Refer to code_ex_16 and sol_07

-- Create/Drop Directory
GRANT CREATE ANY DIRECTORY TO HR;
GRANT DROP ANY DIRECTORY TO HR;

-- For HR@ADB
-- To Upload file into ADB we have to use Object Storage
CREATE DIRECTORY staging AS 'stage';
CREATE DIRECTORY sales_staging AS 'stage/sales';
SELECT * FROM DBMS_CLOUD.LIST_FILES('STAGING');

CREATE OR REPLACE DIRECTORY ROOT_DIR AS '';
SELECT * FROM DBMS_CLOUD.list_files('ROOT_DIR');

-- For rakesh_orcl
CREATE OR REPLACE DIRECTORY REPORTS_DIR as 'D:\C_Workspaces_Repositories\GitHub_Repositories\SQL_Learning\OracleWorkspace\OracleTutorial-OT\PLSQL Learning\plpu\reports';
SET SERVEROUTPUT ON;
EXECUTE read_file('REPORTS_DIR', 'instructor.txt')
EXECUTE sal_status('REPORTS_DIR_1', 'salreport2.txt')

-- For IS_OPEN Check EMPLOYEE_REPORT proc
EXECUTE employee_report('REPORTS_DIR','sal_rpt71.txt')

*****************************************
Dynamic SQL
*****************************************
-- Refer to code_ex_17 and sol_08

-- Dynamic SQL example
drop table t;
drop procedure delete_proc;
create table t (x varchar2(10));

insert into t values (1);

create or replace procedure delete_proc(ptable varchar2) is
begin
    execute immediate 'delete from ' || ptable;
end;

select * from t;

execute delete_proc('t')

begin
    EXECUTE IMMEDIATE 'create table t (x varchar2(10))';
end;

EXECUTE table_pkg.make('my_contacts', 'id number(4), name varchar2(40)')

SELECT * FROM V$SESSION WHERE STATUS = 'ACTIVE';
SELECT * FROM V$OPEN_CURSOR WHERE SID = 36573;

*****************************************
Triggers
*****************************************
-- Refer to code_ex_18 and sol_09 for Row/Statement level Triggers 
-- Refer to code_ex_19 and sol_10 for Advanced level Triggers 

create table salary_log
(
    whodidit varchar2(25),
    whendidit timestamp,
    oldsalary number,
    newsalary number,
    emp_affected number
);
/

CREATE OR REPLACE TRIGGER saltrig AFTER
    INSERT OR UPDATE OF salary ON employees
    FOR EACH ROW
--DECLARE
    --PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO salary_log VALUES (
        user,
        sysdate,
        :old.salary,
        :new.salary,
        :new.employee_id
    );
    --COMMIT;
    /*
        Will be successfully Compiled,
        But during run time will throw below error :-
        ORA-04092: cannot COMMIT in a trigger.
        To fix this issue, make this block AUTONOMOUS_TRANSACTION
        and issue COMMIT.
    */
END;
/

update employees set salary=1 where employee_id=100;
update employees set salary=2400 where employee_id=100;

delete from salary_log;
select * from salary_log;
select * from employees where employee_id = 100;
rollback;

-- Triggers Data Dictionary
select * from user_triggers;
select * from user_errors; -- to see any triggger compilation errors

SELECT COLUMN_NAME, COLUMN_ID
FROM   all_tab_columns
WHERE  table_name = upper('user_triggers')
ORDER BY COLUMN_ID;

*****************************************
Autonomous Transaction
*****************************************
-- Refer to code_ex_20 and sol_11

create table commit_table (id number);
create table non_commit_table (id number);
/

create or replace procedure commitproc(pid number) is
pragma autonomous_transaction; -- mandatory
begin
insert into commit_table values(pid);
commit; -- mandatory
end;
/

create or replace procedure noncommitproc(pid number) is
begin
insert into non_commit_table
values(pid);
commitproc(pid);
end;
/

execute noncommitproc(1000);
/

select * from commit_table;
select * from non_commit_table;
rollback;

*****************************************
Performance Directive
*****************************************
-- Refer to code_ex_20

-- NOCOPY
-- To Test this Turn on ALL Warnings in Preferences >> Database >> PL/SQL Compiler
create or replace procedure get_employee
(
    p_empid in employees.employee_id%type,
    p_sal out employees.salary%type,
    --p_job out employees.job_id%type
    p_job out NOCOPY employees.job_id%type
)
is
begin
    select salary, job_id
    into p_sal, p_job
    from employees
    where employee_id = p_empid;
end;
/

show errors;
/

-- RETURNING
SET SERVEROUTPUT ON;
declare
    v_name employees.last_name%type;
    v_new_sal employees.salary%type;
begin
    update employees
    set salary = salary * 1.1
    where employee_id in (100)
    returning last_name, salary into v_name, v_new_sal;
    
    /*select last_name, salary
    into v_name, v_new_sal
    from employees
    where employee_id = p_emp_id;*/
    
    dbms_output.put_line(v_name || ' new salary is ' || v_new_sal); 
end;
/

*****************************************
Bulk Binding
*****************************************
-- Refer to code_ex_20 and sol_11
CREATE TABLE parts2 ( pnum INTEGER, pname VARCHAR2(15) );
/
CREATE TABLE parts2 ( pnum INTEGER, pname VARCHAR2(15) );
/

DECLARE 
 TYPE NumTab IS TABLE OF parts1.pnum%TYPE INDEX BY PLS_INTEGER;
 TYPE NameTab IS TABLE OF parts1.pname%TYPE INDEX BY PLS_INTEGER;
 pnums NumTab;
 pnames NameTab;
 
 iterations CONSTANT PLS_INTEGER := 5; 
 t1 INTEGER; 
 t2 INTEGER; 
 t3 INTEGER; 
BEGIN
 FOR j IN 1..iterations LOOP -- populate collections 
  pnums(j) := j;
  pnames(j) := 'Part No. ' || TO_CHAR(j); 
 END LOOP;
 
 t1 := DBMS_UTILITY.get_time;
 
 -- Standard For Loop (Slower)
 FOR i IN 1..iterations LOOP 
  INSERT INTO parts1 (pnum, pname) VALUES (pnums(i), pnames(i)); 
 END LOOP;
 
 t2 := DBMS_UTILITY.get_time;
 
 -- Bulk Binding (Faster)
 FORALL i IN 1..iterations 
  INSERT INTO parts2 (pnum, pname) VALUES (pnums(i), pnames(i)); 

 t3 := DBMS_UTILITY.get_time;
 
 DBMS_OUTPUT.PUT_LINE('Execution Time (secs)'); 
 DBMS_OUTPUT.PUT_LINE('---------------------'); 
 DBMS_OUTPUT.PUT_LINE('FOR LOOP: ' || TO_CHAR((t2 - t1)/100));
 DBMS_OUTPUT.PUT_LINE('FORALL: ' || TO_CHAR((t3 - t2)/100)); 
 COMMIT; 
END; 
/

/*
Output:

Execution Time (secs)
---------------------
FOR LOOP: .84
FORALL: .07
*/

select * from parts1;
select * from parts2;

delete from parts1;
delete from parts2;

*****************************************
BULK COLLECT INTO
*****************************************
drop table t;
create table t (empid number);
/

DECLARE 
 TYPE empidTab IS TABLE OF employees.employee_id%TYPE INDEX BY PLS_INTEGER;
 emp_id empidTab;
BEGIN
 -- Bulk Collect
 select employee_id 
 BULK COLLECT INTO emp_id
 from employees 
 where rownum <= 5;
 
 FORALL i IN 1..emp_id.count
  INSERT INTO t VALUES (emp_id(i)); 

 COMMIT; 
END; 
/

select * from t;
delete from t;

*****************************************
BULK COLLECT Exception
*****************************************
drop table exception_test;

/*
CREATE TABLE exception_test (
  id  NUMBER(10)
);
*/

CREATE TABLE exception_test (
  id  NUMBER(10) NOT NULL
);
/

select * from exception_test;

-- Unhandled exception during bulk operation
SET SERVEROUTPUT ON;
DECLARE
  TYPE t_tab IS TABLE OF exception_test.id%TYPE;

  l_tab    t_tab := t_tab();
BEGIN
  -- Fill the collection.
  FOR i IN 1 .. 100 LOOP
    dbms_output.put_line(i || ' index ' || l_tab.last);
    l_tab.extend;
    l_tab(l_tab.last) := i;
  END LOOP;

  -- Cause a failure.
  l_tab(50) := NULL; 

  EXECUTE IMMEDIATE 'TRUNCATE TABLE exception_test';

  -- Perform a bulk operation.
  FORALL i IN l_tab.first .. l_tab.last
    INSERT INTO exception_test
    VALUES (l_tab(i));
END;
/

select * from exception_test; -- no records

-- Handled exception during bulk operation
SET SERVEROUTPUT ON
DECLARE
  TYPE t_tab IS TABLE OF exception_test.id%TYPE;

  l_tab    t_tab := t_tab();
BEGIN
  -- Fill the collection.
  FOR i IN 1 .. 100 LOOP
    l_tab.extend;
    l_tab(l_tab.last) := i;
  END LOOP;

  -- Cause a failure.
  l_tab(50) := NULL; 

  EXECUTE IMMEDIATE 'TRUNCATE TABLE exception_test';

  -- Perform a bulk operation.
  BEGIN
    FORALL i IN l_tab.first .. l_tab.last
      INSERT INTO exception_test
      VALUES (l_tab(i));
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.put_line(SQLERRM);
  END;
END;
/

select * from exception_test; -- 49 records

-- Save Exception during bulk operation
SET SERVEROUTPUT ON
DECLARE
  TYPE t_tab IS TABLE OF exception_test%ROWTYPE;

  l_tab          t_tab := t_tab();
  l_error_count  NUMBER; 

  ex_dml_errors EXCEPTION;
  PRAGMA EXCEPTION_INIT(ex_dml_errors, -24381);
BEGIN
  -- Fill the collection.
  FOR i IN 1 .. 100 LOOP
    l_tab.extend;
    l_tab(l_tab.last).id := i;
  END LOOP;

  -- Cause a failure.
  l_tab(50).id := NULL;
  l_tab(51).id := NULL; 

  EXECUTE IMMEDIATE 'TRUNCATE TABLE exception_test';

  -- Perform a bulk operation.
  BEGIN
    FORALL i IN l_tab.first .. l_tab.last SAVE EXCEPTIONS
      INSERT INTO exception_test
      VALUES l_tab(i);
  EXCEPTION
    WHEN ex_dml_errors THEN
      l_error_count := SQL%BULK_EXCEPTIONS.count;
      DBMS_OUTPUT.put_line('Number of failures: ' || l_error_count);
      FOR i IN 1 .. l_error_count LOOP
        DBMS_OUTPUT.put_line('Error: ' || i ||
          ' Array Index: ' || SQL%BULK_EXCEPTIONS(i).error_index ||
          ' Message: ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE));
      END LOOP;
  END;
END;
/

select * from exception_test; -- 98 records

*****************************************
PL/SQL Initialization Parameters
*****************************************
-- Refer to code_ex_21 and sol_12

-- Check Code Type and Optimization Level
SELECT name, type, plsql_code_type, plsql_optimize_level
FROM user_plsql_object_settings;

-- Change Optimization Level for this Session
ALTER SESSION SET PLSQL_OPTIMIZE_LEVEL=1;
-- 0 = No Optimization
-- 1 = For Debugging
-- 2 = Default
-- 3 = Max Optimization

-- Change Code Type for this Session
ALTER SESSION SET PLSQL_CODE_TYPE= 'NATIVE';
-- NATIVE is for Production
-- INTERPRETED is for Development

-- Compile with Same settings as the Current Session
alter package emp_pkg compile;

-- Compile with Same settings defined for the Object
alter package emp_pkg compile reuse settings;

-- Set Warning Levels
-- Way-1
alter session set PLSQL_WARNINGS='ENABLE:SEVERE', 'ENABLE:PERFORMANCE', 'DISABLE:INFORMATIONAL';
-- Make Warning 05003 as Error
alter session set PLSQL_WARNINGS='ENABLE:SEVERE', 'ENABLE:PERFORMANCE', 'ERROR:05003';
alter session set PLSQL_WARNINGS='ENABLE:INFORMATIONAL';

-- Way-2
-- Enabling all warnings for the current session
execute dbms_warning.set_warning_setting('ENABLE:ALL', 'SESSION');
-- Disabling Performance warning Category for the current session  
execute dbms_warning.add_warning_setting_cat('PERFORMANCE', 'DISABLE', 'SESSION');

-- Show Current Warning level Settings
-- Way-1
select value from v$parameter where name='plsql_warnings';

-- Way-2
set SERVEROUTPUT ON;
execute dbms_output.put_line(dbms_warning.get_warning_setting_string());

-- View all errors/warnings in current session
select * from user_errors;

-- Get Category
SET SERVEROUTPUT ON
EXECUTE DBMS_OUTPUT.PUT_LINE(DBMS_WARNING.GET_CATEGORY(&message));
-- 5001: SEVERE
-- 6001: INFORMATIONAL
-- 7001: PERFORMANCE

*****************************************
Dependencies
*****************************************
-- Refer to code_ex_22 and sol_13

-- Find all the objects dependent on the EMPLOYEES table.
select * 
from user_dependencies 
where referenced_name = 'EMPLOYEES'
order by 2,1;

-- DEPTREE Formation
select * from user_objects order by 8 desc;
-- Created DEPTREE_SEQ, DEPTREE_TEMPTAB, DEPTREE_FILL, 
-- DEPTREE, IDEPTREE

execute deptree_fill('table', 'hr', 'employees');
select * from deptree order by seq#;
select * from ideptree; -- indented

-- Testing
create or replace procedure execute_emp is
    v_sal number;
    v_job varchar2(25);
begin
    get_employee(1000, v_sal, v_job);
end;
/
-- You can see that execute_emp is listed as Level 2 dependency
-- i.e. idirectly dependent

-- Dependent Object Invalidation test
drop table ref_table;
drop view dep_view;
drop procedure dep_proc;
/

-- Reference object
create table ref_table (n number, c varchar2(25));
/

-- Directly dependent Object
create or replace view dep_view as
select n from ref_table;
/

-- Indirectly dependent object
create or replace procedure dep_proc (n1 out number)
as
begin
    select n into n1 from dep_view;
end;
/

insert into ref_table values (1, 'a');
commit;

declare
    n1 number;
begin
    dep_proc(n1);
    dbms_output.put_line(n1);
end;
/

-- Check the Status of the object
select uo.status, ud.*
from user_dependencies ud, user_objects uo
where ud.name = uo.object_name 
and ud.referenced_name in ('REF_TABLE', 'DEP_VIEW')
order by 2,1;

-- Lets Change the datatype of REF_TABLE
truncate table ref_table;
alter table ref_table modify c varchar2(35);
-- if the view is created on column c
-- Both the dependent objects (direct and indirect) are now in-valiadted

-- if the view is created on only column n 
-- Both the dependent objects (direct and indirect) are still valid

*****************************************
Instructions: Advance PL/SQL
*****************************************
In this tutorial we will use OE & HR schema.



*****************************************
Collections
*****************************************
-- Refer to code_ex_03.sql, lab_03.sql & sol_03.sql
-- Refer to code_ex_04.sql, lab_04.sql & & sol_04.sql

select * from customers;

*****************************************
LOBs
*****************************************
-- Refer to code_ex_05.sql, lab_05.sql & sol_05.sql
select * from customers where customer_id = 448;
select * from customers where customer_id = 844;
select * from customer_profiles;
select * from lob_text;
select * from customer_profiles_sf;

*****************************************
JSON
*****************************************
-- Refer to code_ex_06.sql, lab_06.sql & sol_06.sql

*****************************************
Call C and Java Programs
*****************************************
-- Refer to code_ex_07.sql, lab_07.sql & sol_07.sql

*****************************************
Performance Tuning
*****************************************
-- Refer to code_ex_08sql, lab_08.sql & sol_08.sql

*****************************************
Result Cache
*****************************************
-- Refer to code_ex_09.sql, lab_09.sql & sol_09.sql

*****************************************




























